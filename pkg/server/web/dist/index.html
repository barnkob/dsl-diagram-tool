<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DiagTool Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .editor-pane {
            display: flex;
            flex-direction: column;
            min-width: 200px;
            background: #1e1e1e;
        }
        .canvas-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #252526;
            min-width: 200px;
        }
        .resizer {
            width: 4px;
            background: #333;
            cursor: col-resize;
            transition: background 0.2s;
        }
        .resizer:hover, .resizer.active {
            background: #0e639c;
        }
        .header {
            padding: 8px 16px;
            background: #333;
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 13px;
            flex-shrink: 0;
        }
        .header h1 {
            font-size: 14px;
            font-weight: 600;
        }
        .status {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #888;
        }
        .status-dot.connected {
            background: #4caf50;
        }
        .status-dot.error {
            background: #f44336;
        }
        #editor {
            flex: 1;
            width: 100%;
        }
        .canvas-container {
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        #canvas {
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }
        #canvas.dragging {
            cursor: grabbing;
        }
        #canvas svg {
            transform-origin: 0 0;
        }
        /* Edge waypoint styles */
        .waypoint-group {
            pointer-events: all;
        }
        .waypoint {
            fill: #4a6ff3;
            stroke: #fff;
            stroke-width: 2;
            cursor: move;
            transition: fill 0.15s;
        }
        .waypoint:hover {
            fill: #7b9df5;
        }
        .waypoint.dragging {
            fill: #2d4fb8;
        }
        .waypoint.inactive {
            fill: transparent;
            stroke: #4a6ff3;
            stroke-dasharray: 3 3;
            opacity: 0.7;
        }
        .waypoint-delete {
            fill: #e53935;
            stroke: #fff;
            stroke-width: 1.5;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s, fill 0.15s;
        }
        .waypoint-group:hover .waypoint-delete {
            opacity: 1;
        }
        .waypoint-delete:hover {
            fill: #ff6659;
        }
        .waypoint-delete-x {
            stroke: #fff;
            stroke-width: 2;
            stroke-linecap: round;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
        }
        .waypoint-group:hover .waypoint-delete-x {
            opacity: 1;
        }
        .edge-clickable {
            stroke: rgba(74, 111, 243, 0);
            stroke-width: 20;
            fill: none;
            cursor: crosshair;
            pointer-events: stroke;
            transition: stroke 0.15s;
        }
        .edge-clickable:hover {
            stroke: rgba(74, 111, 243, 0.2);
        }
        .error-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            max-height: 40%;
            overflow: auto;
            background: rgba(30, 30, 30, 0.95);
            border-top: 1px solid #f44336;
            display: none;
        }
        .error-container.visible {
            display: block;
        }
        .error-header {
            padding: 8px 12px;
            background: #5a1d1d;
            color: #f88;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .error-close {
            background: none;
            border: none;
            color: #f88;
            cursor: pointer;
            font-size: 16px;
            padding: 0 4px;
        }
        .error-content {
            padding: 12px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            color: #f88;
            line-height: 1.5;
        }
        .toolbar {
            padding: 4px 8px;
            background: #2d2d2d;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-shrink: 0;
        }
        .toolbar button {
            padding: 4px 12px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .toolbar button:hover {
            background: #1177bb;
        }
        .toolbar button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .toolbar button.secondary {
            background: #3c3c3c;
        }
        .toolbar button.secondary:hover {
            background: #4c4c4c;
        }
        .file-path {
            color: #888;
            font-size: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 300px;
        }
        .zoom-controls {
            display: flex;
            gap: 4px;
            align-items: center;
            margin-left: auto;
        }
        .zoom-level {
            font-size: 12px;
            color: #888;
            min-width: 50px;
            text-align: center;
        }
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            background: #333;
            border-radius: 4px;
            font-size: 13px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
            z-index: 1000;
        }
        .toast.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .toast.success {
            background: #1b5e20;
        }
        .toast.warning {
            background: #e65100;
        }
        .file-changed-banner {
            padding: 8px 16px;
            background: #664d00;
            color: #ffd54f;
            font-size: 12px;
            display: none;
            justify-content: space-between;
            align-items: center;
        }
        .file-changed-banner.visible {
            display: flex;
        }
        .file-changed-banner button {
            padding: 2px 8px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="editor-pane" id="editorPane" style="width: 50%;">
            <div class="header">
                <h1>DiagTool Editor</h1>
                <span class="file-path" id="filePath" title=""></span>
                <div class="status">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Connecting...</span>
                </div>
            </div>
            <div class="file-changed-banner" id="fileChangedBanner">
                <span>File changed on disk</span>
                <div>
                    <button onclick="reloadFile()">Reload</button>
                    <button onclick="dismissBanner()" class="secondary">Dismiss</button>
                </div>
            </div>
            <div class="toolbar">
                <button id="saveBtn" disabled>Save (Ctrl+S)</button>
                <span style="border-left: 1px solid #555; height: 20px; margin: 0 4px;"></span>
                <button id="exportSvgBtn" class="secondary" onclick="exportDiagram('svg')">SVG</button>
                <button id="exportPngBtn" class="secondary" onclick="exportDiagram('png')">PNG</button>
                <button id="exportPdfBtn" class="secondary" onclick="exportDiagram('pdf')">PDF</button>
                <span style="border-left: 1px solid #555; height: 20px; margin: 0 4px;"></span>
                <button id="resetLayoutBtn" class="secondary" onclick="resetLayout()" title="Reset to D2 auto-layout">Reset Layout</button>
            </div>
            <div id="editor"></div>
        </div>
        <div class="resizer" id="resizer"></div>
        <div class="canvas-pane">
            <div class="header">
                <h1>Preview</h1>
                <div class="zoom-controls">
                    <button class="secondary" onclick="zoomOut()" title="Zoom out">−</button>
                    <span class="zoom-level" id="zoomLevel">100%</span>
                    <button class="secondary" onclick="zoomIn()" title="Zoom in">+</button>
                    <button class="secondary" onclick="resetZoom()" title="Fit to view">Fit</button>
                </div>
            </div>
            <div class="canvas-container">
                <div id="canvas"></div>
                <div class="error-container" id="errorContainer">
                    <div class="error-header">
                        <span>Compilation Error</span>
                        <button class="error-close" onclick="hideError()">×</button>
                    </div>
                    <div class="error-content" id="errorContent"></div>
                </div>
            </div>
        </div>
    </div>
    <div class="toast" id="toast"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
    <script>
        // Monaco Editor setup
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' } });

        let editor;
        let ws;
        let debounceTimer;
        let isDirty = false;
        let isExporting = false;
        let pendingExternalContent = null;
        const DEBOUNCE_DELAY = 300;

        // Canvas state
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startX, startY;

        // Node dragging state
        let nodePositions = {};  // { nodeId: { dx, dy } }
        let isDraggingNode = false;
        let draggedNode = null;
        let draggedNodeId = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragInitialDX = 0;
        let dragInitialDY = 0;

        // Edge waypoint state
        let edgeWaypoints = {};  // { edgeId: [{ x, y }, ...] }
        let edgeRoutingMode = {};  // { edgeId: "direct"|"orthogonal" }
        let isDraggingWaypoint = false;
        let draggedWaypointEdgeId = null;
        let draggedWaypointIndex = -1;
        let waypointStartX = 0;
        let waypointStartY = 0;
        let hoveredEdgeId = null;  // Track which edge is being hovered for keyboard shortcuts
        let lastMousePosition = { x: 0, y: 0 };  // Track mouse position for 'v' key

        // DOM elements
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const canvas = document.getElementById('canvas');
        const errorContainer = document.getElementById('errorContainer');
        const errorContent = document.getElementById('errorContent');
        const saveBtn = document.getElementById('saveBtn');
        const filePath = document.getElementById('filePath');
        const zoomLevel = document.getElementById('zoomLevel');
        const toast = document.getElementById('toast');
        const fileChangedBanner = document.getElementById('fileChangedBanner');
        const editorPane = document.getElementById('editorPane');
        const resizer = document.getElementById('resizer');
        const exportSvgBtn = document.getElementById('exportSvgBtn');
        const exportPngBtn = document.getElementById('exportPngBtn');
        const exportPdfBtn = document.getElementById('exportPdfBtn');

        // Initialize Monaco Editor
        require(['vs/editor/editor.main'], function () {
            // Register D2 language
            monaco.languages.register({ id: 'd2' });
            monaco.languages.setMonarchTokensProvider('d2', {
                tokenizer: {
                    root: [
                        [/#.*$/, 'comment'],
                        [/"[^"]*"/, 'string'],
                        [/'[^']*'/, 'string'],
                        [/\|[^|]*\|/, 'string.markdown'],
                        [/->|<->|<-|--/, 'operator'],
                        [/\b(shape|style|label|icon|constraint|tooltip|link|near|width|height|direction|grid-rows|grid-columns|grid-gap|vertical-gap|horizontal-gap)\b:/, 'keyword'],
                        [/\b(rectangle|square|page|parallelogram|document|cylinder|queue|package|step|callout|stored_data|person|diamond|oval|circle|hexagon|cloud|text|code|class|sql_table|image|sequence_diagram)\b/, 'type'],
                        [/\b(fill|stroke|stroke-width|stroke-dash|border-radius|opacity|shadow|3d|multiple|double-border|font|font-size|font-color|bold|italic|underline|animated|source-arrowhead|target-arrowhead)\b:/, 'attribute'],
                        [/\b(up|down|left|right)\b/, 'constant'],
                        [/\{/, 'delimiter.bracket'],
                        [/\}/, 'delimiter.bracket'],
                        [/:/, 'delimiter'],
                        [/[a-zA-Z_][a-zA-Z0-9_-]*/, 'identifier'],
                    ]
                }
            });

            // Define D2 theme colors
            monaco.editor.defineTheme('d2-dark', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    { token: 'comment', foreground: '6A9955' },
                    { token: 'string', foreground: 'CE9178' },
                    { token: 'string.markdown', foreground: 'CE9178', fontStyle: 'italic' },
                    { token: 'keyword', foreground: '569CD6' },
                    { token: 'type', foreground: '4EC9B0' },
                    { token: 'attribute', foreground: '9CDCFE' },
                    { token: 'operator', foreground: 'DCDCAA' },
                    { token: 'constant', foreground: 'B5CEA8' },
                    { token: 'identifier', foreground: 'D4D4D4' },
                ],
                colors: {}
            });

            editor = monaco.editor.create(document.getElementById('editor'), {
                value: '# Loading...',
                language: 'd2',
                theme: 'd2-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 14,
                lineNumbers: 'on',
                scrollBeyondLastLine: false,
                wordWrap: 'on',
                tabSize: 2,
                renderWhitespace: 'selection',
                bracketPairColorization: { enabled: true },
            });

            // Listen for changes
            editor.onDidChangeModelContent(() => {
                isDirty = true;
                saveBtn.disabled = false;
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(render, DEBOUNCE_DELAY);
            });

            // Keyboard shortcuts
            editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, save);

            // Connect to WebSocket
            connectWebSocket();
        });

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/api/ws`);

            ws.onopen = () => {
                statusDot.className = 'status-dot connected';
                statusText.textContent = 'Connected';
            };

            ws.onclose = () => {
                statusDot.className = 'status-dot';
                statusText.textContent = 'Reconnecting...';
                setTimeout(connectWebSocket, 2000);
            };

            ws.onerror = () => {
                statusDot.className = 'status-dot error';
                statusText.textContent = 'Error';
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                switch (msg.type) {
                    case 'rendered':
                        showSVG(msg.svg);
                        hideError();
                        break;
                    case 'error':
                        showError(msg.error);
                        setExporting(false);
                        break;
                    case 'file-changed':
                        handleFileChanged(msg.source);
                        break;
                    case 'saved':
                        isDirty = false;
                        saveBtn.disabled = true;
                        showToast('Saved', 'success');
                        break;
                    case 'exported':
                        downloadExport(msg.data, msg.format, msg.filename);
                        setExporting(false);
                        break;
                    case 'positions':
                        nodePositions = msg.positions || {};
                        // Normalize waypoint keys and mark all loaded waypoints as active
                        edgeWaypoints = {};
                        for (const [key, value] of Object.entries(msg.allWaypoints || {})) {
                            // Waypoints from server are always active
                            edgeWaypoints[decodeHtmlEntities(key)] = value.map(wp => ({
                                x: wp.x,
                                y: wp.y,
                                active: true
                            }));
                        }
                        // Normalize routing mode keys
                        edgeRoutingMode = {};
                        for (const [key, value] of Object.entries(msg.allRoutingMode || {})) {
                            edgeRoutingMode[decodeHtmlEntities(key)] = value;
                        }
                        applyNodePositions();
                        break;
                    case 'positions-cleared':
                        nodePositions = {};
                        edgeWaypoints = {};
                        edgeRoutingMode = {};
                        // Re-render to restore original D2 layout
                        render();
                        showToast('Layout reset', 'success');
                        break;
                    case 'position-saved':
                        // Position saved acknowledgment
                        break;
                }
            };
        }

        function handleFileChanged(source) {
            if (isDirty) {
                // Show banner if user has unsaved changes
                pendingExternalContent = source;
                fileChangedBanner.classList.add('visible');
            } else {
                // Auto-reload if no unsaved changes
                if (editor && source !== undefined) {
                    editor.setValue(source);
                    isDirty = false;
                    saveBtn.disabled = true;
                }
            }
        }

        function reloadFile() {
            if (pendingExternalContent !== null) {
                editor.setValue(pendingExternalContent);
                pendingExternalContent = null;
                isDirty = false;
                saveBtn.disabled = true;
            }
            dismissBanner();
        }

        function dismissBanner() {
            fileChangedBanner.classList.remove('visible');
            pendingExternalContent = null;
        }

        function render() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            const source = editor.getValue();
            ws.send(JSON.stringify({ type: 'render', source }));
        }

        function save() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            const source = editor.getValue();
            ws.send(JSON.stringify({ type: 'save', source }));
        }

        function setExporting(state) {
            isExporting = state;
            exportSvgBtn.disabled = state;
            exportPngBtn.disabled = state;
            exportPdfBtn.disabled = state;
            if (state) {
                exportSvgBtn.textContent = 'SVG';
                exportPngBtn.textContent = 'PNG';
                exportPdfBtn.textContent = 'PDF';
            }
        }

        function exportDiagram(format) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                showToast('Not connected', 'warning');
                return;
            }
            if (isExporting) return;

            setExporting(true);
            const btn = format === 'svg' ? exportSvgBtn : format === 'png' ? exportPngBtn : exportPdfBtn;
            btn.textContent = 'Exporting...';

            const source = editor.getValue();
            ws.send(JSON.stringify({ type: 'export', source, format }));
        }

        function downloadExport(base64Data, format, filename) {
            try {
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                const mimeTypes = {
                    'svg': 'image/svg+xml',
                    'png': 'image/png',
                    'pdf': 'application/pdf'
                };

                const blob = new Blob([bytes], { type: mimeTypes[format] });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast('Downloaded ' + filename, 'success');
            } catch (err) {
                showToast('Download failed: ' + err.message, 'warning');
            }
        }

        function resetLayout() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                showToast('Not connected', 'warning');
                return;
            }
            // Clear all position overrides and edge waypoints
            ws.send(JSON.stringify({ type: 'clear-positions' }));
            // The server will broadcast 'positions-cleared' which triggers a re-render
        }

        function showSVG(svg) {
            canvas.innerHTML = svg;
            const svgEl = canvas.querySelector('svg');
            if (svgEl) {
                updateTransform();
                setupNodeDragging();
                setupEdgeWaypoints();
                applyNodePositions();
            }
        }

        // Base64 decode helper
        function decodeBase64(str) {
            try {
                return atob(str);
            } catch (e) {
                return null;
            }
        }

        // ============================================
        // Edge Following Functions
        // ============================================

        // Find all edge groups in the SVG
        function findAllEdges() {
            const svg = canvas.querySelector('svg');
            if (!svg) return [];

            const edges = [];
            const groups = svg.querySelectorAll('g');
            for (const g of groups) {
                const path = g.querySelector('path.connection');
                if (path) {
                    const className = g.getAttribute('class');
                    if (className) {
                        // Try each class to find the edge ID
                        const classes = className.split(/\s+/);
                        for (const cls of classes) {
                            const decoded = decodeBase64(cls);
                            // Edge IDs contain "(" and end with ")[index]"
                            // Top-level: "(source -> target)[0]"
                            // Nested: "prefix.(source -> target)[0]"
                            if (decoded && decoded.includes('(') && /\)\[\d+\]$/.test(decoded)) {
                                edges.push({ group: g, path, edgeId: decoded, originalPath: path.getAttribute('d') });
                                break;
                            }
                        }
                    }
                }
            }
            return edges;
        }

        // Decode HTML entities in a string
        function decodeHtmlEntities(str) {
            const textarea = document.createElement('textarea');
            textarea.innerHTML = str;
            return textarea.value;
        }

        // Parse edge ID to extract source and target node IDs
        // Formats:
        //   "(source -> target)[index]" - top-level edge
        //   "prefix.(source -> target)[index]" - nested edge with container prefix
        // Note: D2 encodes these with HTML entities (e.g., -&gt; instead of ->)
        function parseEdgeId(edgeId) {
            // First decode HTML entities
            const decoded = decodeHtmlEntities(edgeId);

            // Try to match with optional prefix: prefix.(source -> target)[index]
            const match = decoded.match(/^(.*?)\((.+?)\s*(->|<-|<->|--)\s*(.+?)\)\[(\d+)\]$/);
            if (!match) return null;

            let prefix = match[1];
            let source = match[2];
            let target = match[4];
            const direction = match[3];
            const index = parseInt(match[5]);

            // Remove trailing dot from prefix if present
            if (prefix.endsWith('.')) {
                prefix = prefix.slice(0, -1);
            }

            // Prepend prefix to get absolute node IDs
            if (prefix) {
                source = prefix + '.' + source;
                target = prefix + '.' + target;
            }

            return {
                source,
                target,
                direction,
                index,
                prefix: prefix || null
            };
        }

        // Find all edges connected to a specific node
        function findConnectedEdges(nodeId) {
            return findAllEdges().filter(edge => {
                const parsed = parseEdgeId(edge.edgeId);
                return parsed && (parsed.source === nodeId || parsed.target === nodeId);
            });
        }

        // Get the bounding box of a node (accounting for position offset)
        function getNodeBounds(nodeId) {
            const nodes = findDraggableNodes();
            const node = nodes.find(n => n.nodeId === nodeId);
            if (!node) return null;

            // Get the shape element's bounding box
            const shape = node.element.querySelector('.shape');
            if (!shape) return null;

            const bbox = shape.getBBox();
            const offset = nodePositions[nodeId] || { dx: 0, dy: 0 };

            return {
                x: bbox.x + offset.dx,
                y: bbox.y + offset.dy,
                width: bbox.width,
                height: bbox.height,
                cx: bbox.x + bbox.width / 2 + offset.dx,
                cy: bbox.y + bbox.height / 2 + offset.dy
            };
        }

        // Calculate the intersection point of a line from center to target on a rectangle boundary
        function getRectEdgePoint(bounds, targetX, targetY) {
            const cx = bounds.cx;
            const cy = bounds.cy;
            const hw = bounds.width / 2;  // half width
            const hh = bounds.height / 2; // half height

            // Direction vector from center to target
            const dx = targetX - cx;
            const dy = targetY - cy;

            // Handle case where target is at the same position
            if (dx === 0 && dy === 0) {
                return { x: cx, y: cy - hh }; // Default to top
            }

            // Calculate intersection with rectangle edges
            // We need to find the parameter t where the line intersects the rectangle
            let t = Infinity;

            // Check intersection with each edge
            if (dx !== 0) {
                // Right edge (x = cx + hw)
                const tRight = hw / Math.abs(dx);
                // Left edge (x = cx - hw)
                const tLeft = hw / Math.abs(dx);
                t = Math.min(t, dx > 0 ? tRight : tLeft);
            }
            if (dy !== 0) {
                // Bottom edge (y = cy + hh)
                const tBottom = hh / Math.abs(dy);
                // Top edge (y = cy - hh)
                const tTop = hh / Math.abs(dy);
                t = Math.min(t, dy > 0 ? tBottom : tTop);
            }

            // If direction is zero in one axis, t is already correct from the other axis
            if (dx === 0) t = hh / Math.abs(dy);
            if (dy === 0) t = hw / Math.abs(dx);

            return {
                x: cx + dx * t,
                y: cy + dy * t
            };
        }

        // Arrow marker offset - D2 arrows have refX=7 with width=10, so tip extends ~3-4px past path end
        // We need to shorten the path so arrow tip lands on the node edge
        const ARROW_OFFSET = 4;

        // Shorten a point along a line by a given distance
        function shortenPoint(point, towardX, towardY, distance) {
            const dx = towardX - point.x;
            const dy = towardY - point.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) return point;

            // Move point toward the target by 'distance'
            return {
                x: point.x + (dx / len) * distance,
                y: point.y + (dy / len) * distance
            };
        }

        // Calculate edge path between two nodes with proper edge anchoring
        function calculateEdgePath(sourceBounds, targetBounds, hasSourceArrow, hasTargetArrow) {
            // Get intersection points on the edge of each rectangle
            let sourcePoint = getRectEdgePoint(sourceBounds, targetBounds.cx, targetBounds.cy);
            let targetPoint = getRectEdgePoint(targetBounds, sourceBounds.cx, sourceBounds.cy);

            // Shorten path to account for arrow markers
            // Move target point inward so arrow tip lands on node edge
            if (hasTargetArrow !== false) {
                targetPoint = shortenPoint(targetPoint, sourceBounds.cx, sourceBounds.cy, ARROW_OFFSET);
            }
            // Move source point inward if there's a source arrow (bidirectional)
            if (hasSourceArrow === true) {
                sourcePoint = shortenPoint(sourcePoint, targetBounds.cx, targetBounds.cy, ARROW_OFFSET);
            }

            return `M ${sourcePoint.x} ${sourcePoint.y} L ${targetPoint.x} ${targetPoint.y}`;
        }

        // Determine arrow presence based on edge direction
        // -> : target has arrow
        // <- : source has arrow
        // <-> : both have arrows
        // -- : no arrows
        function getArrowInfo(direction) {
            switch (direction) {
                case '->':
                    return { hasSourceArrow: false, hasTargetArrow: true };
                case '<-':
                    return { hasSourceArrow: true, hasTargetArrow: false };
                case '<->':
                    return { hasSourceArrow: true, hasTargetArrow: true };
                case '--':
                    return { hasSourceArrow: false, hasTargetArrow: false };
                default:
                    return { hasSourceArrow: false, hasTargetArrow: true };
            }
        }

        // Update all edges connected to a node
        function updateConnectedEdges(nodeId) {
            const connectedEdges = findConnectedEdges(nodeId);

            for (const edge of connectedEdges) {
                const parsed = parseEdgeId(edge.edgeId);
                if (!parsed) continue;

                // Skip self-referencing edges
                if (parsed.source === parsed.target) continue;

                const sourceBounds = getNodeBounds(parsed.source);
                const targetBounds = getNodeBounds(parsed.target);

                if (sourceBounds && targetBounds) {
                    const arrowInfo = getArrowInfo(parsed.direction);
                    const key = getEdgeKey(edge.edgeId);
                    const waypoints = edgeWaypoints[key] || [];
                    const routingMode = edgeRoutingMode[key] || 'direct';
                    const newPath = calculateEdgePathWithWaypoints(
                        sourceBounds, targetBounds, waypoints,
                        arrowInfo.hasSourceArrow, arrowInfo.hasTargetArrow, routingMode
                    );
                    edge.path.setAttribute('d', newPath);

                    // Update clickable overlay too
                    const clickable = edge.group.querySelector('.edge-clickable');
                    if (clickable) {
                        clickable.setAttribute('d', newPath);
                    }
                }
            }

            // Re-render waypoints to update their positions
            renderWaypoints();
        }

        // Update all edges in the diagram
        function updateAllEdges() {
            const allEdges = findAllEdges();
            for (const edge of allEdges) {
                const parsed = parseEdgeId(edge.edgeId);
                if (!parsed) continue;

                // Skip self-referencing edges
                if (parsed.source === parsed.target) continue;

                const sourceBounds = getNodeBounds(parsed.source);
                const targetBounds = getNodeBounds(parsed.target);

                if (sourceBounds && targetBounds) {
                    const arrowInfo = getArrowInfo(parsed.direction);
                    const key = getEdgeKey(edge.edgeId);
                    const waypoints = edgeWaypoints[key] || [];
                    const routingMode = edgeRoutingMode[key] || 'direct';
                    const newPath = calculateEdgePathWithWaypoints(
                        sourceBounds, targetBounds, waypoints,
                        arrowInfo.hasSourceArrow, arrowInfo.hasTargetArrow, routingMode
                    );
                    edge.path.setAttribute('d', newPath);

                    // Update clickable overlay too
                    const clickable = edge.group.querySelector('.edge-clickable');
                    if (clickable) {
                        clickable.setAttribute('d', newPath);
                    }
                }
            }

            // Re-render waypoints to update their positions
            renderWaypoints();
        }

        // Request a full re-render from the server to get proper D2 edge routing
        function requestRerender() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            const source = editor.getValue();
            ws.send(JSON.stringify({ type: 'render', source }));
        }

        // ============================================
        // Edge Waypoint Functions
        // ============================================

        // Calculate edge path with waypoints, supporting different routing modes
        function calculateEdgePathWithWaypoints(sourceBounds, targetBounds, waypoints, hasSourceArrow, hasTargetArrow, routingMode) {
            routingMode = routingMode || 'direct';

            // Filter to only include active waypoints for path calculation
            const activeWaypoints = (waypoints || []).filter(wp => wp.active !== false);

            if (routingMode === 'orthogonal') {
                return calculateOrthogonalPath(sourceBounds, targetBounds, activeWaypoints, hasSourceArrow, hasTargetArrow);
            }

            // Default: direct (straight lines)
            return calculateDirectPath(sourceBounds, targetBounds, activeWaypoints, hasSourceArrow, hasTargetArrow);
        }

        // Calculate direct (straight line) path through waypoints
        function calculateDirectPath(sourceBounds, targetBounds, waypoints, hasSourceArrow, hasTargetArrow) {
            if (!waypoints || waypoints.length === 0) {
                return calculateEdgePath(sourceBounds, targetBounds, hasSourceArrow, hasTargetArrow);
            }

            // Get first waypoint to calculate source intersection
            const firstWaypoint = waypoints[0];
            let sourcePoint = getRectEdgePoint(sourceBounds, firstWaypoint.x, firstWaypoint.y);
            if (hasSourceArrow) {
                sourcePoint = shortenPoint(sourcePoint, firstWaypoint.x, firstWaypoint.y, ARROW_OFFSET);
            }

            // Get last waypoint to calculate target intersection
            const lastWaypoint = waypoints[waypoints.length - 1];
            let targetPoint = getRectEdgePoint(targetBounds, lastWaypoint.x, lastWaypoint.y);
            if (hasTargetArrow !== false) {
                targetPoint = shortenPoint(targetPoint, lastWaypoint.x, lastWaypoint.y, ARROW_OFFSET);
            }

            // Build path: source -> waypoints -> target
            let path = `M ${sourcePoint.x} ${sourcePoint.y}`;
            for (const wp of waypoints) {
                path += ` L ${wp.x} ${wp.y}`;
            }
            path += ` L ${targetPoint.x} ${targetPoint.y}`;

            return path;
        }

        // Calculate orthogonal (right-angle) path through waypoints
        function calculateOrthogonalPath(sourceBounds, targetBounds, waypoints, hasSourceArrow, hasTargetArrow) {
            // Determine first target point for source exit direction
            const firstTarget = (waypoints && waypoints.length > 0)
                ? waypoints[0]
                : { x: targetBounds.cx, y: targetBounds.cy };

            // Calculate source exit point (prefer horizontal/vertical exit)
            let sourcePoint = getOrthogonalExitPoint(sourceBounds, firstTarget);
            if (hasSourceArrow) {
                // Shorten along the exit direction
                const exitDir = getExitDirection(sourceBounds, sourcePoint);
                sourcePoint = shortenPointOrthogonal(sourcePoint, exitDir, ARROW_OFFSET);
            }

            // Determine last source point for target entry direction
            const lastSource = (waypoints && waypoints.length > 0)
                ? waypoints[waypoints.length - 1]
                : sourcePoint;

            // Calculate target entry point
            let targetPoint = getOrthogonalExitPoint(targetBounds, lastSource);
            if (hasTargetArrow !== false) {
                const entryDir = getExitDirection(targetBounds, targetPoint);
                targetPoint = shortenPointOrthogonal(targetPoint, entryDir, ARROW_OFFSET);
            }

            // Build path with orthogonal segments
            const points = [sourcePoint];

            // Add intermediate points for orthogonal routing between waypoints
            let prevPoint = sourcePoint;
            for (const wp of (waypoints || [])) {
                // Add orthogonal bend point(s) between prevPoint and waypoint
                const bendPoints = getOrthogonalBendPoints(prevPoint, wp);
                points.push(...bendPoints);
                points.push(wp);
                prevPoint = wp;
            }

            // Add final orthogonal segments to target
            const finalBends = getOrthogonalBendPoints(prevPoint, targetPoint);
            points.push(...finalBends);
            points.push(targetPoint);

            // Build SVG path
            let path = `M ${points[0].x} ${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                path += ` L ${points[i].x} ${points[i].y}`;
            }

            return path;
        }

        // Get orthogonal exit point from a node bounds
        function getOrthogonalExitPoint(bounds, target) {
            const cx = bounds.cx, cy = bounds.cy;
            const hw = bounds.width / 2, hh = bounds.height / 2;

            // Determine primary direction to target
            const dx = target.x - cx;
            const dy = target.y - cy;

            // Choose exit side based on which direction is dominant
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal dominant - exit from left or right
                if (dx > 0) {
                    return { x: cx + hw, y: cy }; // right
                } else {
                    return { x: cx - hw, y: cy }; // left
                }
            } else {
                // Vertical dominant - exit from top or bottom
                if (dy > 0) {
                    return { x: cx, y: cy + hh }; // bottom
                } else {
                    return { x: cx, y: cy - hh }; // top
                }
            }
        }

        // Get exit direction from a bounds given an exit point
        function getExitDirection(bounds, exitPoint) {
            const cx = bounds.cx, cy = bounds.cy;
            if (Math.abs(exitPoint.x - cx) > Math.abs(exitPoint.y - cy)) {
                return exitPoint.x > cx ? 'right' : 'left';
            } else {
                return exitPoint.y > cy ? 'down' : 'up';
            }
        }

        // Shorten a point along an orthogonal direction
        function shortenPointOrthogonal(point, direction, offset) {
            switch (direction) {
                case 'right': return { x: point.x - offset, y: point.y };
                case 'left': return { x: point.x + offset, y: point.y };
                case 'down': return { x: point.x, y: point.y - offset };
                case 'up': return { x: point.x, y: point.y + offset };
                default: return point;
            }
        }

        // Get bend points for orthogonal routing between two points
        function getOrthogonalBendPoints(from, to) {
            // If already aligned, no bend needed
            if (Math.abs(from.x - to.x) < 1 || Math.abs(from.y - to.y) < 1) {
                return [];
            }

            // Create one bend point (L-shaped path)
            // Prefer horizontal-then-vertical or vertical-then-horizontal based on distance
            const midX = (from.x + to.x) / 2;
            const midY = (from.y + to.y) / 2;

            // Use midpoint strategy for cleaner routing
            if (Math.abs(from.x - to.x) > Math.abs(from.y - to.y)) {
                // Horizontal dominant: go horizontal first, then vertical
                return [{ x: midX, y: from.y }, { x: midX, y: to.y }];
            } else {
                // Vertical dominant: go vertical first, then horizontal
                return [{ x: from.x, y: midY }, { x: to.x, y: midY }];
            }
        }

        // Get the edge ID key for waypoints storage (normalized)
        // Normalizes by decoding HTML entities so keys match consistently
        function getEdgeKey(edgeId) {
            return decodeHtmlEntities(edgeId);
        }

        // Setup clickable edges and waypoints after SVG is rendered
        function setupEdgeWaypoints() {
            const allEdges = findAllEdges();

            for (const edge of allEdges) {
                // Add clickable overlay for adding waypoints
                const clickable = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                clickable.setAttribute('class', 'edge-clickable');
                clickable.setAttribute('d', edge.path.getAttribute('d'));
                clickable.dataset.edgeId = edge.edgeId;

                // Double-click to add waypoint (Structurizr-style)
                clickable.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    const svg = canvas.querySelector('svg');
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    // getScreenCTM().inverse() already converts to SVG coordinate space
                    const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());

                    addWaypoint(edge.edgeId, svgPt.x, svgPt.y);
                });

                // Track hovered edge for keyboard shortcuts
                clickable.addEventListener('mouseenter', () => {
                    hoveredEdgeId = edge.edgeId;
                });
                clickable.addEventListener('mouseleave', () => {
                    if (hoveredEdgeId === edge.edgeId) {
                        hoveredEdgeId = null;
                    }
                });
                // Track mouse position for 'v' key
                clickable.addEventListener('mousemove', (e) => {
                    const svg = canvas.querySelector('svg');
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    // getScreenCTM().inverse() already converts to SVG coordinate space
                    const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
                    lastMousePosition.x = svgPt.x;
                    lastMousePosition.y = svgPt.y;
                });

                // Insert AFTER the path so it's on top and can receive click events
                edge.group.appendChild(clickable);
            }

            // Render existing waypoints
            renderWaypoints();
        }

        // Add a waypoint to an edge
        function addWaypoint(edgeId, x, y) {
            const key = getEdgeKey(edgeId);
            if (!edgeWaypoints[key]) {
                edgeWaypoints[key] = [];
            }

            // Find the best position to insert the waypoint
            const waypoints = edgeWaypoints[key];
            let insertIndex = waypoints.length; // Default: append at end

            if (waypoints.length > 0) {
                // Find which segment the click is closest to
                const parsed = parseEdgeId(edgeId);
                if (parsed) {
                    const sourceBounds = getNodeBounds(parsed.source);
                    const targetBounds = getNodeBounds(parsed.target);

                    if (sourceBounds && targetBounds) {
                        // Build list of points: source, waypoints, target
                        const points = [
                            { x: sourceBounds.cx, y: sourceBounds.cy },
                            ...waypoints,
                            { x: targetBounds.cx, y: targetBounds.cy }
                        ];

                        // Find closest segment
                        let minDist = Infinity;
                        for (let i = 0; i < points.length - 1; i++) {
                            const dist = pointToSegmentDistance(x, y, points[i], points[i + 1]);
                            if (dist < minDist) {
                                minDist = dist;
                                insertIndex = i;
                            }
                        }
                    }
                }
            }

            // Insert waypoint at the best position (inactive until dragged)
            waypoints.splice(insertIndex, 0, { x, y, active: false });

            // Render waypoints (but don't update edge path since waypoint is inactive)
            renderWaypoints();
            // Don't save yet - will save when waypoint is activated by dragging
        }

        // Calculate distance from point to line segment
        function pointToSegmentDistance(px, py, p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const lenSq = dx * dx + dy * dy;

            if (lenSq === 0) {
                return Math.sqrt((px - p1.x) ** 2 + (py - p1.y) ** 2);
            }

            let t = ((px - p1.x) * dx + (py - p1.y) * dy) / lenSq;
            t = Math.max(0, Math.min(1, t));

            const nearX = p1.x + t * dx;
            const nearY = p1.y + t * dy;

            return Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2);
        }

        // Remove a waypoint
        function removeWaypoint(edgeId, index) {
            const key = getEdgeKey(edgeId);
            if (!edgeWaypoints[key]) return;

            edgeWaypoints[key].splice(index, 1);
            if (edgeWaypoints[key].length === 0) {
                delete edgeWaypoints[key];
            }

            updateEdgeWithWaypoints(edgeId);
            renderWaypoints();
            saveWaypoints(edgeId);
        }

        // Update a single edge with its waypoints
        function updateEdgeWithWaypoints(edgeId) {
            const allEdges = findAllEdges();
            const edge = allEdges.find(e => e.edgeId === edgeId);
            if (!edge) return;

            const parsed = parseEdgeId(edgeId);
            if (!parsed || parsed.source === parsed.target) return;

            const sourceBounds = getNodeBounds(parsed.source);
            const targetBounds = getNodeBounds(parsed.target);
            if (!sourceBounds || !targetBounds) return;

            const key = getEdgeKey(edgeId);
            const waypoints = edgeWaypoints[key] || [];
            const routingMode = edgeRoutingMode[key] || 'direct';
            const arrowInfo = getArrowInfo(parsed.direction);

            const newPath = calculateEdgePathWithWaypoints(
                sourceBounds, targetBounds, waypoints,
                arrowInfo.hasSourceArrow, arrowInfo.hasTargetArrow, routingMode
            );

            edge.path.setAttribute('d', newPath);

            // Update clickable overlay too
            const clickable = edge.group.querySelector('.edge-clickable');
            if (clickable) {
                clickable.setAttribute('d', newPath);
            }
        }

        // Render all waypoint handles with X delete buttons (Structurizr-style)
        function renderWaypoints() {
            const svg = canvas.querySelector('svg');
            if (!svg) return;

            // Remove existing waypoint groups
            svg.querySelectorAll('.waypoint-group').forEach(el => el.remove());

            // Create waypoint groups for each edge
            for (const [edgeId, waypoints] of Object.entries(edgeWaypoints)) {
                const allEdges = findAllEdges();
                // Match using normalized edge ID
                const edge = allEdges.find(e => getEdgeKey(e.edgeId) === edgeId);
                if (!edge) continue;

                waypoints.forEach((wp, index) => {
                    // Create group for waypoint + delete button
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.setAttribute('class', 'waypoint-group');
                    group.setAttribute('transform', `translate(${wp.x}, ${wp.y})`);

                    // Main drag circle
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    // Add 'inactive' class if waypoint is not yet active
                    const waypointClass = wp.active === false ? 'waypoint inactive' : 'waypoint';
                    circle.setAttribute('class', waypointClass);
                    circle.setAttribute('cx', 0);
                    circle.setAttribute('cy', 0);
                    circle.setAttribute('r', 6);
                    circle.dataset.edgeId = edgeId;
                    circle.dataset.waypointIndex = index;

                    // Delete button (small circle with X, positioned top-right)
                    const deleteBtn = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    deleteBtn.setAttribute('class', 'waypoint-delete');
                    deleteBtn.setAttribute('cx', 10);
                    deleteBtn.setAttribute('cy', -10);
                    deleteBtn.setAttribute('r', 7);

                    // X lines inside delete button
                    const xLine1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    xLine1.setAttribute('class', 'waypoint-delete-x');
                    xLine1.setAttribute('x1', 7);
                    xLine1.setAttribute('y1', -13);
                    xLine1.setAttribute('x2', 13);
                    xLine1.setAttribute('y2', -7);

                    const xLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    xLine2.setAttribute('class', 'waypoint-delete-x');
                    xLine2.setAttribute('x1', 13);
                    xLine2.setAttribute('y1', -13);
                    xLine2.setAttribute('x2', 7);
                    xLine2.setAttribute('y2', -7);

                    // Drag to move (on main circle)
                    circle.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return;
                        e.stopPropagation();

                        isDraggingWaypoint = true;
                        draggedWaypointEdgeId = edgeId;
                        draggedWaypointIndex = index;
                        waypointStartX = e.clientX;
                        waypointStartY = e.clientY;
                        circle.classList.add('dragging');
                        circle.classList.remove('inactive');

                        // Activate the waypoint on drag start
                        const key = getEdgeKey(edgeId);
                        if (edgeWaypoints[key] && edgeWaypoints[key][index]) {
                            edgeWaypoints[key][index].active = true;
                            // Update edge path now that waypoint is active
                            updateEdgeWithWaypoints(edgeId);
                        }
                    });

                    // Click X button to remove (Structurizr-style)
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeWaypoint(edgeId, index);
                    });

                    group.appendChild(circle);
                    group.appendChild(deleteBtn);
                    group.appendChild(xLine1);
                    group.appendChild(xLine2);
                    svg.appendChild(group);
                });
            }
        }

        // Save waypoints to server
        function saveWaypoints(edgeId) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            const key = getEdgeKey(edgeId);
            const allWaypoints = edgeWaypoints[key] || [];
            // Only save active waypoints, and strip the 'active' flag (all saved are active)
            const waypoints = allWaypoints
                .filter(wp => wp.active !== false)
                .map(wp => ({ x: wp.x, y: wp.y }));

            ws.send(JSON.stringify({
                type: 'waypoints',
                edgeId: edgeId,
                waypoints: waypoints
            }));
        }

        // Toggle routing mode for an edge (direct -> orthogonal -> direct)
        function toggleRoutingMode(edgeId) {
            const key = getEdgeKey(edgeId);
            const currentMode = edgeRoutingMode[key] || 'direct';
            const modes = ['direct', 'orthogonal'];
            const currentIndex = modes.indexOf(currentMode);
            const nextMode = modes[(currentIndex + 1) % modes.length];

            edgeRoutingMode[key] = nextMode;
            updateEdgeWithWaypoints(edgeId);
            saveRoutingMode(edgeId, nextMode);
            showToast(`Routing: ${nextMode}`, 'success');
        }

        // Save routing mode to server
        function saveRoutingMode(edgeId, mode) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            ws.send(JSON.stringify({
                type: 'routing',
                edgeId: edgeId,
                routingMode: mode
            }));
        }

        // Get routing mode for an edge
        function getRoutingMode(edgeId) {
            const key = getEdgeKey(edgeId);
            return edgeRoutingMode[key] || 'direct';
        }

        // ============================================
        // End Edge Waypoint Functions
        // ============================================

        // ============================================
        // End Edge Following Functions
        // ============================================

        // Get node ID from SVG group element
        function getNodeId(element) {
            const className = element.getAttribute('class');
            if (!className) return null;

            // D2 uses base64-encoded node IDs as class names
            // Only single-word classes (no spaces) are node IDs
            const classes = className.split(/\s+/);
            for (const cls of classes) {
                // Skip known D2 classes
                if (cls.startsWith('d2-') || cls === 'shape' || cls === 'connection') continue;

                const decoded = decodeBase64(cls);
                if (decoded && !decoded.includes(' ') && decoded.length > 0) {
                    // Looks like a valid node ID
                    return decoded;
                }
            }
            return null;
        }

        // Find all draggable nodes in SVG
        function findDraggableNodes() {
            const svgEl = canvas.querySelector('svg');
            if (!svgEl) return [];

            const nodes = [];
            // Find all direct children g elements with base64 class names
            const groups = svgEl.querySelectorAll('g');
            for (const g of groups) {
                const nodeId = getNodeId(g);
                // Only top-level node groups (has shape child, not a connection)
                if (nodeId && g.querySelector('.shape') && !nodeId.startsWith('(')) {
                    nodes.push({ element: g, nodeId });
                }
            }
            return nodes;
        }

        // Set up drag handlers on nodes
        function setupNodeDragging() {
            const nodes = findDraggableNodes();
            for (const { element, nodeId } of nodes) {
                element.style.cursor = 'move';

                element.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    e.stopPropagation(); // Prevent canvas panning

                    isDraggingNode = true;
                    draggedNode = element;
                    draggedNodeId = nodeId;

                    // Get current position offset
                    const pos = nodePositions[nodeId] || { dx: 0, dy: 0 };
                    dragInitialDX = pos.dx;
                    dragInitialDY = pos.dy;

                    // Store start position (account for zoom)
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;

                    element.style.opacity = '0.8';
                });
            }
        }

        // Apply stored positions to nodes and update edges
        function applyNodePositions() {
            const nodes = findDraggableNodes();
            for (const { element, nodeId } of nodes) {
                const pos = nodePositions[nodeId];
                if (pos) {
                    element.style.transform = `translate(${pos.dx}px, ${pos.dy}px)`;
                } else {
                    element.style.transform = '';
                }
            }

            // Update all edges to follow node positions
            updateAllEdges();
        }

        // Global mouse move handler for node and waypoint dragging
        document.addEventListener('mousemove', (e) => {
            // Handle waypoint dragging
            if (isDraggingWaypoint && draggedWaypointEdgeId !== null) {
                const key = getEdgeKey(draggedWaypointEdgeId);
                if (edgeWaypoints[key] && edgeWaypoints[key][draggedWaypointIndex]) {
                    // Get the SVG point for accurate positioning
                    const svg = canvas.querySelector('svg');
                    const pt = svg.createSVGPoint();
                    pt.x = e.clientX;
                    pt.y = e.clientY;
                    // getScreenCTM().inverse() already converts to SVG coordinate space
                    const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());

                    // Preserve the active flag when updating position
                    const currentWaypoint = edgeWaypoints[key][draggedWaypointIndex];
                    edgeWaypoints[key][draggedWaypointIndex] = {
                        x: svgPt.x,
                        y: svgPt.y,
                        active: currentWaypoint.active
                    };

                    updateEdgeWithWaypoints(draggedWaypointEdgeId);
                    renderWaypoints();
                }
                return;
            }

            // Handle node dragging
            if (!isDraggingNode || !draggedNode) return;

            // Calculate delta (account for zoom)
            const dx = (e.clientX - dragStartX) / zoom;
            const dy = (e.clientY - dragStartY) / zoom;

            // Apply transform
            const newDX = dragInitialDX + dx;
            const newDY = dragInitialDY + dy;
            draggedNode.style.transform = `translate(${newDX}px, ${newDY}px)`;

            // Update connected edges to follow the node
            nodePositions[draggedNodeId] = { dx: newDX, dy: newDY };
            updateConnectedEdges(draggedNodeId);
        });

        // Global mouse up handler for node and waypoint dragging
        document.addEventListener('mouseup', (e) => {
            // Handle waypoint drag end
            if (isDraggingWaypoint && draggedWaypointEdgeId !== null) {
                // Save the waypoint position
                saveWaypoints(draggedWaypointEdgeId);

                // Remove dragging class from waypoint
                const svg = canvas.querySelector('svg');
                if (svg) {
                    svg.querySelectorAll('.waypoint.dragging').forEach(el => el.classList.remove('dragging'));
                }

                // Reset state
                isDraggingWaypoint = false;
                draggedWaypointEdgeId = null;
                draggedWaypointIndex = -1;
                return;
            }

            // Handle node drag end
            if (!isDraggingNode || !draggedNode) return;

            // Calculate final delta
            const dx = (e.clientX - dragStartX) / zoom;
            const dy = (e.clientY - dragStartY) / zoom;
            const finalDX = dragInitialDX + dx;
            const finalDY = dragInitialDY + dy;

            // Store position locally
            nodePositions[draggedNodeId] = { dx: finalDX, dy: finalDY };

            // Send to server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'position',
                    nodeId: draggedNodeId,
                    dx: finalDX,
                    dy: finalDY
                }));
            }

            // Reset state
            draggedNode.style.opacity = '';
            isDraggingNode = false;
            draggedNode = null;
            draggedNodeId = null;

            // Request a re-render to get D2's proper edge routing
            // The re-render will produce new SVG, then applyNodePositions()
            // will reapply the CSS transforms and recalculate edges
            requestRerender();
        });

        function showError(error) {
            // Parse error to highlight line numbers
            const formatted = error.replace(/line (\d+)/gi, '<strong>line $1</strong>');
            errorContent.innerHTML = formatted;
            errorContainer.classList.add('visible');
        }

        function hideError() {
            errorContainer.classList.remove('visible');
        }

        function showToast(message, type = '') {
            toast.textContent = message;
            toast.className = 'toast visible ' + type;
            setTimeout(() => {
                toast.classList.remove('visible');
            }, 2000);
        }

        // Zoom controls
        function zoomIn() {
            zoom = Math.min(zoom * 1.25, 5);
            updateTransform();
        }

        function zoomOut() {
            zoom = Math.max(zoom / 1.25, 0.1);
            updateTransform();
        }

        function resetZoom() {
            const svgEl = canvas.querySelector('svg');
            if (!svgEl) return;

            const container = canvas.parentElement;
            const containerRect = container.getBoundingClientRect();
            const svgRect = svgEl.getBoundingClientRect();

            // Get the natural size from viewBox
            const viewBox = svgEl.getAttribute('viewBox');
            if (viewBox) {
                const [, , width, height] = viewBox.split(' ').map(Number);
                const scaleX = (containerRect.width - 40) / width;
                const scaleY = (containerRect.height - 40) / height;
                zoom = Math.min(scaleX, scaleY, 1);
            } else {
                zoom = 1;
            }

            panX = 20;
            panY = 20;
            updateTransform();
        }

        function updateTransform() {
            const svgEl = canvas.querySelector('svg');
            if (svgEl) {
                svgEl.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            }
            zoomLevel.textContent = Math.round(zoom * 100) + '%';
        }

        // Pan controls
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0 && !isDraggingNode) {
                isPanning = true;
                startX = e.clientX - panX;
                startY = e.clientY - panY;
                canvas.classList.add('dragging');
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isPanning && !isDraggingNode) {
                panX = e.clientX - startX;
                panY = e.clientY - startY;
                updateTransform();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (!isDraggingNode) {
                isPanning = false;
                canvas.classList.remove('dragging');
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (!isDraggingNode) {
                isPanning = false;
                canvas.classList.remove('dragging');
            }
        });

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(5, zoom * delta));

            // Zoom towards mouse position
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const dx = (mouseX - panX) * (1 - newZoom / zoom);
            const dy = (mouseY - panY) * (1 - newZoom / zoom);

            panX += dx;
            panY += dy;
            zoom = newZoom;

            updateTransform();
        }, { passive: false });

        // Keyboard shortcuts for edge waypoints (Structurizr-style)
        document.addEventListener('keydown', (e) => {
            // Only handle when hovering over an edge
            if (!hoveredEdgeId) return;

            // Don't intercept when typing in editor
            if (document.activeElement && document.activeElement.closest('.monaco-editor')) return;

            const key = e.key.toLowerCase();

            if (key === 'r') {
                // Toggle routing mode: direct -> orthogonal -> direct
                toggleRoutingMode(hoveredEdgeId);
                e.preventDefault();
            } else if (key === 'v') {
                // Add vertex at current mouse position
                addWaypoint(hoveredEdgeId, lastMousePosition.x, lastMousePosition.y);
                e.preventDefault();
            }
        });

        // Resizer
        let isResizing = false;

        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizer.classList.add('active');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const containerWidth = document.querySelector('.container').offsetWidth;
            const newWidth = Math.max(200, Math.min(e.clientX, containerWidth - 200));
            editorPane.style.width = newWidth + 'px';
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                resizer.classList.remove('active');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        // Save button click
        saveBtn.addEventListener('click', save);

        // Fetch file path on load
        fetch('/api/file')
            .then(res => res.json())
            .then(data => {
                if (data.filePath) {
                    const shortPath = data.filePath.split('/').slice(-2).join('/');
                    filePath.textContent = shortPath;
                    filePath.title = data.filePath;
                }
            });

        // Auto-fit on first render
        let firstRender = true;
        const originalShowSVG = showSVG;
        showSVG = function(svg) {
            originalShowSVG(svg);
            if (firstRender) {
                firstRender = false;
                setTimeout(resetZoom, 100);
            }
        };
    </script>
</body>
</html>
